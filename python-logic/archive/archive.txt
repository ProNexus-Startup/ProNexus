def parse_email_thread(raw_email_content: str):
    message = message_from_string(raw_email_content)
    emails = []
    if message.is_multipart():
        # Walk through all parts of the email to find embedded email objects
        for part in message.walk():
            # Check if the part is another email message as per MIME type
            if part.get_content_type() == 'message/rfc822':
                # message/rfc822 indicates the part is a full email message itself
                nested_message = part.get_payload(0)  # Assuming there is only one payload in this part
                if nested_message.is_multipart():
                    emails.extend(parse_email_thread(nested_message.as_string()))
                else:
                    email_dict = extract_email_data(nested_message)
                    emails.append(email_dict)
    else:
        email_dict = extract_email_data(message)
        emails.append(email_dict)
    return emails

def extract_email_data(email_message):
    """Extracts email data into a dictionary containing all necessary fields."""
    print("Headers Available:", email_message.keys())  # Debug: print all available headers

    # Check if each header is available and print its value
    for header in ['From', 'To', 'Subject', 'X-IsMeeting', 'X-MeetingMessageType']:
        print(f"{header}: {email_message.get(header, 'Not Available')}")

    # Handle multipart content
    content = ''
    if email_message.is_multipart():
        for part in email_message.walk():
            if part.get_content_type() == 'text/plain':
                content += part.get_payload(decode=True).decode('utf-8')
    else:
        content = email_message.get_payload(decode=True).decode('utf-8')

    return {
        'from': email_message.get('From'),
        'to': email_message.get('To'),
        'subject': email_message.get('Subject'),
        'body': content,
        'isMeeting': email_message.get('X-IsMeeting', False),
        'meetingMessageType': email_message.get('X-MeetingMessageType', '')
    }

# Separate email threads
def separate_emails(thread):
    print(thread)
    print("Headers Available:", thread.keys())  # Debug: print all available headers
    print(thread['id'])
    print('hereherehere')
    separated_emails = {}
    for email in thread:
        thread_id = email.get('conversationId')
        if thread_id not in separated_emails:
            separated_emails[thread_id] = []
        separated_emails[thread_id].append(email)
    return separated_emails


for email in emails:
            email_dict = {
                'subject': email.get('subject', 'No Subject'),
                'from': email.get('sender', {}).get('emailAddress', {}).get('address', 'Unknown Email'),
                #'to': ', '.join([rec.get('emailAddress', {}).get('address', 'Unknown Email') for rec in email.get('toRecipients', [])]),
                'body': email.get('body', {}).get('content', 'No Content')
            }

            # Checking for attachments
            has_attachments = email.get('hasAttachments', False)
            if has_attachments:
                attachment_url = f"https://graph.microsoft.com/v1.0/users/{user_id_or_principal_name}/messages/{email['id']}/attachments"
                attachment_response = requests.get(attachment_url, headers=headers)
                attachments = attachment_response.json().get('value', [])
                email_dict['Attachments'] = [attachment.get('name', 'Unnamed Attachment') for attachment in attachments]
            else:
                email_dict['Attachments'] = []